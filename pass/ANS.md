載下題目檔案，這是一個binary檔
基本上在打PWN題目時，透過一些輸入，讓執行程式出現漏洞，使其吐出flag。

所以目標很明確的就是要得到對方SERVER的flag

而現在執行的話就是在自己電腦上跑，所以你拿到shell的話也是自己電腦上的shell，但我們目標是拿到遠端的shell

    通常題目都會提供nc，並附上遠端server ip & port，nc是一個指令，讓你可以遠端到對方電腦查看題目

    nc過去只能輸入東西並查看程式的輸出，如果是在自己電腦的話就可以用GDB去追或是patch之類的

**總結就是遠端只是一個原始的binary，你只能對他做輸入的動作**

在分析這種題目時，如果題目有給source code的話，可以先做分析，再從中找可以利用的漏洞。

從這source code可以看到，26行讀入的字與18行寫的KEY長度有點出入，造成了buffer overflow的問題

    所謂buffer overflow就是，輸入的文字長度，是超過原先預設的長度

這裡的KEY預設長度是16個字，卻可以輸入40個字，而多出來的24個字，並不會不見，而會存到stack上的某個地方，但出現這個問題時，不一定會出錯。

基本上就是希望可以多寫到的地方，可以去覆蓋到一些不該覆蓋到的地方，進而改寫記憶體上其他的值


![pwn](https://github.com/Trinity-SYT-SECURITY/PWN/raw/main/pass/execpass.png)
>這題在執行後，雖然可能蓋到了其他記憶體中的值，但並沒有使程式掛掉

然後在分析這程式時，可以用GDB來看
    GDB是Linux的Debuger，可以透過他看正在執行的東西，也就是進入可以一步步查看程式所做的動作
    執行過程中，可以一邊看他reg的值跟stack的變化(記憶體空間變化)，或透過指令修改程式流程或是值

```cpp
b main
r
ni =>這裡一直按enter，主要想看程式的26、32行動作



```